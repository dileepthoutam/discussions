Core Concepts

1.What is an API

2.REST vs GraphQL

3.HTTP methods (GET, POST, PUT etc)

4.HTTP status codes (2xx, 4xx, 5xx)

5.Stateless vs Stateful APIs

6.Authentication vs Authorization

7.Session-based auth vs JWT

8.OAuth 2.0 (Login with Google, GitHub, etc.) 9. Rate limiting vs Throttling

10.Idempotency (especially for payments)

Databases & Data Handling

11.SQL vs NoSQL â€” when to use what

12.Indexes and how they speed up queries

13.ACID properties

14.Transactions & isolation levels

15.Database normalization vs denormalization

16.Pagination (offset vs cursor-based)

17.Sharding & partitioning

18.Read replicas & write scaling

19.Handling duplicate records

20.Optimistic vs pessimistic locking

Caching & Performance

21.What is caching and where to cache

22.Cache eviction strategies (TTL, LRU)

23.Cache consistency & stale cache problems

24.CDN and edge caching

25.Why cache can make systems wrong

Distributed Systems & Scaling 26. Load balancing (round-robin, least connections, hashing)

27.Horizontal vs vertical scaling 28. Microservices vs monoliths (trade-offs) 29. Service-to-service communication (sync vs

async)

30.Message queues (Kafka, RabbitMQ, SQS)

Reliability & Real-World Problems

31.Exactly-once vs at-least-once processing

32.Retries, timeouts, and circuit breakers

33.Handling race conditions

34.Distributed locking

35.Event-driven architecture

36.Saga pattern (distributed transactions) 37.Graceful degradation

38.Observability (logs, metrics, tracing)

39.Deployments (blue-green, rolling)

40.Handling traffic spikes & viral load